domain IArray  {
  
  function slot(a: IArray, i: Int): Ref 
  
  function alen(a: IArray): Int 
  
  function first(r: Ref): IArray 
  
  function second(r: Ref): Int 
  
  axiom all_diff {
    (forall a: IArray, i: Int ::
      { slot(a, i) }
      first(slot(a, i)) == a && second(slot(a, i)) == i)
  }
  
  axiom len_nonneg {
    (forall a: IArray :: { alen(a) } alen(a) >= 0)
  }
}

domain BitVectorDomain64 interpretation (SMTLIB: "(_ BitVec 64)", Boogie: "bv64") {
  
  function not(a: BitVectorDomain64): BitVectorDomain64 interpretation "bvnot"
  
  function bv64_xor(a: BitVectorDomain64, b: BitVectorDomain64): BitVectorDomain64 interpretation "bvxor"
  
  function bv64_and(a: BitVectorDomain64, b: BitVectorDomain64): BitVectorDomain64 interpretation "bvand"
  
  function bv64_or(a: BitVectorDomain64, b: BitVectorDomain64): BitVectorDomain64 interpretation "bvor"
  
  function bv64_shl(a: BitVectorDomain64, b: BitVectorDomain64): BitVectorDomain64 interpretation "bvshl"
  
  function bv64_lshr(a: BitVectorDomain64, b: BitVectorDomain64): BitVectorDomain64 interpretation "bvlshr"
  
  function bv64_ashr(a: BitVectorDomain64, b: BitVectorDomain64): BitVectorDomain64 interpretation "bvashr"
  
  function bv64_from_int(i: Int): BitVectorDomain64 interpretation "(_ int2bv 64)"
  
  function bv64_to_int(i: BitVectorDomain64): Int interpretation "(_ bv2int 64)"
}

field heap_elem: Int

function sum(heap: IArray, base: Int, len: Int): Int
  requires base >= 0 && len >= 0
  requires base + len <= alen(heap)
  requires (forall i: Int ::base <= i && i < base + len ==>
      acc(slot(heap, i).heap_elem, wildcard))

{
  (len == 0 ?
    0 :
    slot(heap, base + len - 1).heap_elem + sum(heap, base, len - 1))
}

method copy_slice(src: IArray, src_idx: Int, dst: IArray, dst_idx: Int, length: Int)
  requires 0 <= src_idx
  requires src_idx <= alen(src)
  requires src_idx + length <= alen(src)
  requires (forall j: Int ::0 <= src_idx && src_idx <= j &&
      (j < src_idx + length && src_idx + length <= alen(src)) ==>
      acc(slot(src, j).heap_elem, wildcard))
  requires 0 <= dst_idx
  requires dst_idx <= alen(dst)
  requires dst_idx + length <= alen(dst)
  requires (forall j: Int ::0 <= dst_idx && dst_idx <= j &&
      (j < dst_idx + length && dst_idx + length <= alen(dst)) ==>
      acc(slot(dst, j).heap_elem, write))
  ensures (forall j: Int ::0 <= src_idx && src_idx <= j &&
      (j < src_idx + length && src_idx + length <= alen(src)) ==>
      acc(slot(src, j).heap_elem, wildcard))
  ensures (forall j: Int ::0 <= dst_idx && dst_idx <= j &&
      (j < dst_idx + length && dst_idx + length <= alen(dst)) ==>
      acc(slot(dst, j).heap_elem, write))
  ensures (forall i: Int ::0 <= i && i < length ==>
      old(slot(src, src_idx + i).heap_elem) ==
      slot(src, src_idx + i).heap_elem)
  ensures (forall i: Int ::0 <= i && i < length ==>
      slot(src, src_idx + i).heap_elem == slot(dst, dst_idx + i).heap_elem)


method create_slice(src: IArray, src_idx: Int, length: Int)
  returns (dst: IArray)
  requires 0 <= src_idx
  requires src_idx <= alen(src)
  requires src_idx + length <= alen(src)
  requires (forall j: Int ::0 <= src_idx && src_idx <= j &&
      (j < src_idx + length && src_idx + length <= alen(src)) ==>
      acc(slot(src, j).heap_elem, wildcard))
  ensures length == alen(dst)
  ensures (forall j: Int ::0 <= src_idx && src_idx <= j &&
      (j < src_idx + length && src_idx + length <= alen(src)) ==>
      acc(slot(src, j).heap_elem, wildcard))
  ensures (forall j: Int ::0 <= 0 && 0 <= j &&
      (j < 0 + length && 0 + length <= alen(dst)) ==>
      acc(slot(dst, j).heap_elem, write))
  ensures (forall i: Int ::0 <= i && i < length ==>
      old(slot(src, src_idx + i).heap_elem) ==
      slot(src, src_idx + i).heap_elem)
  ensures (forall i: Int ::0 <= i && i < length ==>
      slot(src, src_idx + i).heap_elem == slot(dst, i).heap_elem)
{
  inhale length == alen(dst)
  inhale (forall j: Int ::0 <= 0 && 0 <= j &&
      (j < 0 + length && 0 + length <= alen(dst)) ==>
      acc(slot(dst, j).heap_elem, write))
  copy_slice(src, src_idx, dst, 0, length)
}

method shared_load(address: Int) returns (value: Int)


method shared_store(address: Int, value: Int)


method f_main(heap: IArray) returns (retval: Int)
  requires alen(heap) == 16384
{
  retval := 0
  goto return_label
  label return_label
  refute false
}

method f_array_sum(heap: IArray, arg_arr: Int, arg_len: Int)
  returns (retval: Int)
  requires alen(heap) == 16384
  requires arg_arr >= 0 && arg_len >= 0
  requires arg_arr % 8 == 0
  requires arg_arr / 8 + arg_len <= alen(heap)
  requires (forall i: Int ::arg_arr / 8 <= i && i < arg_arr / 8 + arg_len ==>
      acc(slot(heap, i).heap_elem, wildcard))
  ensures (forall i: Int ::arg_arr / 8 <= i && i < arg_arr / 8 + arg_len ==>
      acc(slot(heap, i).heap_elem, wildcard))
  ensures sum(heap, arg_arr / 8, arg_len) == retval
{
  var array_sum_arr_0: Int
  var array_sum_len_1: Int
  array_sum_arr_0 := arg_arr
  array_sum_len_1 := arg_len
  // annotation pushed
  // annotation pushed
  // annotation pushed
  // annotation pushed
  // annotation pushed
  // annotation pushed
  {
    var array_sum_i_2: Int
    array_sum_i_2 := 0
    {
      var array_sum_accu_3: Int
      array_sum_accu_3 := 0
      while ((array_sum_i_2 < array_sum_len_1 ? 1 : 0) != 0)
        invariant array_sum_arr_0 % 8 == 0
        invariant 0 <= array_sum_i_2 && array_sum_i_2 <= array_sum_len_1
        invariant (forall i: Int ::array_sum_arr_0 / 8 <= i &&
            i < array_sum_arr_0 / 8 + array_sum_len_1 ==>
            acc(slot(heap, i).heap_elem, wildcard))
        invariant array_sum_accu_3 ==
          sum(heap, array_sum_arr_0 / 8, array_sum_i_2) 
      {
        // annotation pushed
        // annotation pushed
        // annotation pushed
        // annotation pushed
        {
          var array_sum_tmp_4: Int
          assert (array_sum_arr_0 + array_sum_i_2 * 8) % 8 == 0
          array_sum_tmp_4 := slot(heap, (array_sum_arr_0 +
            array_sum_i_2 * 8) /
            8).heap_elem
          array_sum_accu_3 := array_sum_accu_3 + array_sum_tmp_4
          array_sum_i_2 := array_sum_i_2 + 1
        }
        label continue_label_0
      }
      label break_label_0
      retval := array_sum_accu_3
      goto return_label
    }
  }
  label return_label
  refute false
}